import itertools
import re
import sys
import threading
import time
from functools import wraps
from typing import Any, Dict  # noqa: F401

from uaclient import config, exceptions, messages
from uaclient.api.u.pro.security.vulnerabilities.cve.v1 import (
    CVEVulnerabilitiesOptions,
)
from uaclient.api.u.pro.security.vulnerabilities.cve.v1 import (
    _vulnerabilities_with_applied_fixes_count as cve_vulnerabilities,
)
from uaclient.api.u.pro.security.vulnerabilities.usn.v1 import (
    USNVulnerabilitiesOptions,
)
from uaclient.api.u.pro.security.vulnerabilities.usn.v1 import (
    _vulnerabilities_with_applied_fixes_count as usn_vulnerabilities,
)
from uaclient.cli.commands import ProArgument, ProArgumentGroup, ProCommand
from uaclient.cli.formatter import Block, Table, create_link
from uaclient.cli.vulnerability import util as vuln_util


def _create_usn_table(usns, num_rows=None):
    usns_sorted_by_name = sorted(usns, key=lambda usn: usn.name)

    if num_rows:
        usns_sorted_by_name = usns_sorted_by_name[:num_rows]

    return Table(
        headers=[
            "VULNERABILITY",
            "FIX AVAILABLE FROM",
            "AFFECTED INSTALLED PACKAGES",
        ],
        rows=[
            [
                create_link(
                    text=usn.name,
                    url="https://ubuntu.com/security/notices/{}".format(
                        usn.name
                    ),
                ),
                ", ".join(
                    set(
                        [
                            pkg.fix_available_from or "no-fix"
                            for pkg in usn.affected_packages
                        ]
                    )
                ),
                ", ".join(set([pkg.name for pkg in usn.affected_packages])),
            ]
            for usn in usns_sorted_by_name
        ],
    )


def _create_cve_table(cves, num_rows=None):
    cves_sorted_by_priority = sorted(
        cves,
        key=lambda cve: (
            vuln_util.CVE_PRIORITIES.index(cve.ubuntu_priority),
            cve.name,
        ),
    )

    if num_rows:
        cves_sorted_by_priority = cves_sorted_by_priority[:num_rows]

    return Table(
        headers=[
            "VULNERABILITY",
            "PRIORITY",
            "FIX AVAILABLE FROM",
            "AFFECTED INSTALLED PACKAGES",
        ],
        rows=[
            [
                create_link(
                    text=cve.name,
                    url="https://ubuntu.com/security/{}".format(cve.name),
                ),
                vuln_util.get_priority_with_color(cve.ubuntu_priority),
                ", ".join(
                    set(
                        [
                            pkg.fix_available_from or "no-fix"
                            for pkg in cve.affected_packages
                        ]
                    )
                ),
                ", ".join(set([pkg.name for pkg in cve.affected_packages])),
            ]
            for cve in cves_sorted_by_priority
        ],
    )


def _get_unfixable_info_from_vulnerabilities(vulnerabilities):
    count = 0
    vulnerability_count_info = {}  # type: Dict[str, int]

    for vuln in vulnerabilities:
        if vuln.fixable != "yes":
            count += 1

            if not getattr(vuln, "ubuntu_priority", None):
                continue

            if vuln.ubuntu_priority in vulnerability_count_info:
                vulnerability_count_info[vuln.ubuntu_priority] += 1
            else:
                vulnerability_count_info[vuln.ubuntu_priority] = 1

    return (count, vulnerability_count_info)


def _get_info_from_vulnerabilities(vulnerabilities):
    vulnerability_count_info = {
        "ubuntu_security": {"count": 0, "info": {}},
        "ubuntu_pro": {
            "count": 0,
            "info": {},
        },
    }  # type: Dict[str, Dict[str, Any]]

    for vuln in vulnerabilities:
        if vuln.fixable == "yes":
            pockets = set()
            for pkg in vuln.affected_packages:
                if re.match(
                    r"^(esm|fips)", pkg.fix_available_from or "no-fix"
                ):
                    pockets.add("ubuntu_pro")
                else:
                    pockets.add("ubuntu_security")

            for pocket in pockets:
                vulnerability_count_info[pocket]["count"] += 1

                if not getattr(vuln, "ubuntu_priority", None):
                    continue

                if (
                    vuln.ubuntu_priority
                    in vulnerability_count_info[pocket]["info"]
                ):
                    vulnerability_count_info[pocket]["info"][
                        vuln.ubuntu_priority
                    ] += 1
                else:
                    vulnerability_count_info[pocket]["info"][
                        vuln.ubuntu_priority
                    ] = 1

    return vulnerability_count_info


def _get_fixable_color_count(pocket_info):
    if "critical" in pocket_info["info"]:
        main_color = messages.TxtColor.FAIL
    elif "high" in pocket_info["info"]:
        main_color = messages.TxtColor.ORANGE
    elif "medium" in pocket_info["info"]:
        main_color = messages.TxtColor.WARNINGYELLOW
    elif "low" in pocket_info["info"]:
        main_color = messages.TxtColor.INFOBLUE
    else:
        main_color = ""

    if main_color:
        return "{}{}{}".format(
            main_color,
            str(pocket_info["count"]),
            messages.TxtColor.ENDC,
        )

    return str(pocket_info["count"])


def _get_count_msg_by_priority(count_by_priority):
    msgs = []
    sorted_priority_count = sorted(
        count_by_priority.items(),
        key=lambda item: vuln_util.CVE_PRIORITIES.index(item[0]),
    )

    for priority, count in sorted_priority_count:
        if count:
            msgs.append(
                "{} {}".format(
                    count, vuln_util.get_priority_with_color(priority)
                )
            )

    return ", ".join(msgs)


def _create_fixable_cves_count(vulnerabilities) -> str:
    content = []
    fixable_vulnerabilities_info = _get_info_from_vulnerabilities(
        vulnerabilities
    )

    for pocket, pocket_info in sorted(fixable_vulnerabilities_info.items()):
        if not pocket_info["count"]:
            continue

        content.append(
            "{} {} ({})".format(
                _get_fixable_color_count(pocket_info),
                messages.CLI_VULNERABILITY_LIST_FIXES_AVAILABLE_COUNT.format(
                    pocket=pocket.title().replace("_", " ")
                ),
                _get_count_msg_by_priority(pocket_info["info"]),
            )
        )

    return Block(
        title=messages.CLI_VULNERABILITY_LIST_FIXES_AVAILABLE_HEADER,
        content=content,
    ).to_string()


def _create_fixable_usns_count(vulnerabilities) -> str:
    content = []
    fixable_vulnerabilities_info = _get_info_from_vulnerabilities(
        vulnerabilities
    )
    for pocket, pocket_info in sorted(fixable_vulnerabilities_info.items()):
        if not pocket_info["count"]:
            continue

        content.append(
            "{} {}".format(
                str(pocket_info["count"]),
                messages.CLI_VULNERABILITY_LIST_FIXES_AVAILABLE_COUNT.format(
                    pocket=pocket.title().replace("_", " ")
                ),
            )
        )

    return Block(
        title=messages.CLI_VULNERABILITY_LIST_FIXES_AVAILABLE_HEADER,
        content=content,
    ).to_string()


def _create_unfixable_cves_count(vulnerabilities) -> str:
    count, unfixable_vulnerabilities_info = (
        _get_unfixable_info_from_vulnerabilities(vulnerabilities)  # noqa
    )

    return Block(
        title=messages.CLI_VULNERABILITY_LIST_UNFIXABLE_AVAILABLE_HEADER,
        content=[
            "{} {} ({})".format(
                str(count),
                messages.CLI_VULNERABILITY_LIST_UNFIXABLE_AVAILABLE_COUNT,
                _get_count_msg_by_priority(unfixable_vulnerabilities_info),
            )
        ],
    ).to_string()


def _create_unfixable_usns_count(vulnerabilities) -> str:
    count, unfixable_vulnerabilities_info = (
        _get_unfixable_info_from_vulnerabilities(vulnerabilities)  # noqa
    )

    return Block(
        title=messages.CLI_VULNERABILITY_LIST_UNFIXABLE_AVAILABLE_HEADER,
        content=[
            "{} {}".format(
                str(count),
                messages.CLI_VULNERABILITY_LIST_UNFIXABLE_AVAILABLE_COUNT,
            )
        ],
    ).to_string()


def _create_already_fixed_cves_count(applied_fixes_count) -> str:
    if any(count for pocket, count in applied_fixes_count["count"].items()):
        content = []
        for pocket, count in sorted(applied_fixes_count["count"].items()):
            if not count:
                continue

            content.append(
                "{}{}{} {} {} ({})".format(
                    messages.TxtColor.DISABLEGREY,
                    str(count),
                    messages.TxtColor.ENDC,
                    messages.CLI_VULNERABILITY_LIST_FIXES_APPLIED_COUNT,
                    pocket.title().replace("_", " "),
                    _get_count_msg_by_priority(
                        applied_fixes_count.get("info", {}).get(pocket, {})
                    ),
                )
            )

        return Block(
            title=messages.CLI_VULNERABILITY_LIST_FIXES_APPLIED_HEADER,
            content=content,
        ).to_string()

    return ""


def _create_already_fixed_usns_count(applied_fixes_count) -> str:
    if any(count for pocket, count in applied_fixes_count["count"].items()):
        content = []
        for pocket, count in sorted(applied_fixes_count["count"].items()):
            if not count:
                continue

            content.append(
                "{} {} {}".format(
                    str(count),
                    messages.CLI_VULNERABILITY_LIST_FIXES_APPLIED_COUNT,
                    pocket.title().replace("_", " "),
                )
            )

        return Block(
            title=messages.CLI_VULNERABILITY_LIST_FIXES_APPLIED_HEADER,
            content=content,
        ).to_string()

    return ""


def _create_list_header(
    vulnerabilities,
    applied_fixes_count,
    show_usns: bool,
    show_all: bool,
    show_unfixable: bool,
) -> str:
    msg = ""
    if show_usns:
        msg += _create_already_fixed_usns_count(applied_fixes_count)
        msg += "\n"
        if show_all:
            msg += _create_fixable_usns_count(vulnerabilities)
            msg += "\n"
            msg += _create_unfixable_usns_count(vulnerabilities)
        elif show_unfixable:
            msg += _create_unfixable_usns_count(vulnerabilities)
        else:
            msg += _create_fixable_usns_count(vulnerabilities)
    else:
        msg += _create_already_fixed_cves_count(applied_fixes_count)
        msg += "\n"
        if show_all:
            msg += _create_fixable_cves_count(vulnerabilities)
            msg += "\n"
            msg += _create_unfixable_cves_count(vulnerabilities)
        elif show_unfixable:
            msg += _create_unfixable_cves_count(vulnerabilities)
        else:
            msg += _create_fixable_cves_count(vulnerabilities)

    return msg


def run_spinner(stop_spinner):
    spinner = itertools.cycle(["|", "/", "-", "\\"])
    while not stop_spinner.is_set():
        sys.stdout.write(next(spinner))
        sys.stdout.flush()
        time.sleep(0.1)
        sys.stdout.write("\b")


def with_spinner():
    def wrapper(f):
        @wraps(f)
        def new_f(args, *, cfg, **kwargs):
            print(messages.CLI_VULNERABILITY_LIST_SPINNER_MSG)
            if not sys.stdout.isatty():
                return f(args, cfg=cfg, **kwargs)

            stop_spinner = threading.Event()

            spinner_thread = threading.Thread(
                target=run_spinner, args=(stop_spinner,)
            )
            spinner_thread.start()

            retval = f(args, cfg=cfg, **kwargs)

            stop_spinner.set()
            spinner_thread.join()
            sys.stdout.write("\b")

            return retval

        return new_f

    return wrapper


@with_spinner()
@vuln_util.assert_data_cache_updated("pro vulnerability list")
def _get_cve_data(args, *, cfg: config.UAConfig, **kwargs):
    cve_options = CVEVulnerabilitiesOptions(
        all=args.all,
        unfixable=args.unfixable,
        data_file=args.data_file,
        manifest_file=args.manifest_file,
        series=args.series,
    )
    return cve_vulnerabilities(
        options=cve_options,
        cfg=cfg,
    )


def _list_cves(
    args,
    cfg: config.UAConfig,
):
    cve_vulnerabilities_result, applied_fixes_count = _get_cve_data(
        args,
        cfg=cfg,
    )

    if cve_vulnerabilities_result.cves:
        print(messages.CLI_VULNERABILITY_LIST_CVE_HEADER)
        print(_create_cve_table(cve_vulnerabilities_result.cves))
        print(
            _create_list_header(
                vulnerabilities=cve_vulnerabilities_result.cves,
                applied_fixes_count=applied_fixes_count,
                show_usns=False,
                show_all=args.all,
                show_unfixable=args.unfixable,
            )
        )
    else:
        print(
            messages.CLI_VULNERABILITY_LIST_NOT_AFFECTED.format(issue="CVEs")
            + "\n"
        )
        print(_create_already_fixed_cves_count(applied_fixes_count))


@with_spinner()
@vuln_util.assert_data_cache_updated("pro vulnerability list")
def _get_usn_data(args, *, cfg: config.UAConfig, **kwargs):
    usn_options = USNVulnerabilitiesOptions(
        all=args.all,
        unfixable=args.unfixable,
        data_file=args.data_file,
        manifest_file=args.manifest_file,
        series=args.series,
    )
    return usn_vulnerabilities(
        options=usn_options,
        cfg=cfg,
    )


def _list_usns(
    args,
    cfg: config.UAConfig,
):
    usn_vulnerabilities_result, applied_fixes_count = _get_usn_data(
        args,
        cfg=cfg,
    )

    if usn_vulnerabilities_result.usns:
        print(messages.CLI_VULNERABILITY_LIST_USN_HEADER)
        print(_create_usn_table(usn_vulnerabilities_result.usns))
        print(
            _create_list_header(
                vulnerabilities=usn_vulnerabilities_result.usns,
                applied_fixes_count=applied_fixes_count,
                show_usns=True,
                show_all=args.all,
                show_unfixable=args.unfixable,
            )
        )
    else:
        print(
            messages.CLI_VULNERABILITY_LIST_NOT_AFFECTED.format(issue="USNs")
            + "\n"
        )
        print(_create_already_fixed_usns_count(applied_fixes_count))


def action_list(args, *, cfg, **kwargs):
    if args.unfixable and args.all:
        raise exceptions.InvalidOptionCombination(
            option1="unfixable", option2="all"
        )

    if args.usns:
        _list_usns(
            args,
            cfg=cfg,
        )
    else:
        _list_cves(
            args,
            cfg=cfg,
        )


list_subcommand = ProCommand(
    "list",
    help=messages.CLI_VULNERABILITY_LIST,
    description=messages.CLI_VULNERABILITY_LIST_DESC,
    action=action_list,
    preserve_description=True,
    argument_groups=[
        ProArgumentGroup(
            arguments=[
                ProArgument(
                    "--data-file",
                    help=messages.CLI_VULNERABILITY_DATA_FILE,
                    action="store",
                ),
                ProArgument(
                    "--all",
                    help=messages.CLI_VULNERABILITY_LIST_ALL,
                    action="store_true",
                ),
                ProArgument(
                    "--usns",
                    help=messages.CLI_VULNERABILITY_LIST_USNS,
                    action="store_true",
                ),
                ProArgument(
                    "--unfixable",
                    help=messages.CLI_VULNERABILITY_LIST_UNFIXABLE,
                    action="store_true",
                ),
                ProArgument(
                    "--manifest-file",
                    help=messages.CLI_VULNERABILITY_LIST_MANIFEST_FILE,
                    action="store",
                ),
                ProArgument(
                    "--series",
                    help=messages.CLI_VULNERABILITY_LIST_SERIES,
                    action="store",
                ),
                ProArgument(
                    "--update",
                    help=messages.CLI_VULNERABILITY_UPDATE,
                    action="store_true",
                ),
            ]
        )
    ],
)
