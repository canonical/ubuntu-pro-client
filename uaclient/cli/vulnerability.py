from functools import wraps
from urllib.parse import urljoin

from uaclient import config, defaults, messages
from uaclient.api.u.pro.security.vulnerabilities._common.v1 import (
    VulnerabilityData,
)
from uaclient.api.u.pro.security.vulnerabilities.cve.v1 import (
    CVEVulnerabilitiesOptions,
)
from uaclient.api.u.pro.security.vulnerabilities.cve.v1 import (
    _vulnerabilities as cve_vulnerabilities,
)
from uaclient.cli import cli_util
from uaclient.cli.commands import ProArgument, ProArgumentGroup, ProCommand


def _parse_cache_time_diff(cache_time_diff) -> int:
    if cache_time_diff.days >= 1:
        return cache_time_diff.days

    return round(cache_time_diff.total_seconds() / 3600)


def assert_data_cache_updated(vulnerability_cmd=None):
    def wrapper(f):
        @wraps(f)
        def new_f(args, *, cfg, **kwargs):
            vulnerability_data = VulnerabilityData(cfg)
            update = getattr(args, "update", False)

            if update:
                vulnerability_data.get()
            else:
                cache_valid, cache_time_diff = (
                    vulnerability_data.is_cache_valid()
                )

                if not cache_valid and not cache_time_diff:
                    vulnerability_data.get()
                elif not cache_valid:
                    print(
                        messages.CLI_VULNERABILITY_DATE_OUTDATED.format(
                            t_diff=_parse_cache_time_diff(cache_time_diff),
                            cmd=vulnerability_cmd or "",
                        )
                    )

            retval = f(args, cfg=cfg, **kwargs)
            return retval

        return new_f

    return wrapper


def _show_base_info(vulnerability_result, vulnerability_issue):
    print("‚óè {}".format(vulnerability_issue.name))
    print(
        messages.CLI_VULNERABILITY_SHOW_PUBLIC_URL.format(
            urljoin(defaults.BASE_SECURITY_URL, vulnerability_issue.name)
        )
    )
    print(
        messages.CLI_VULNERABILITY_SHOW_PUBLISHED_AT.format(
            vulnerability_issue.published_at.strftime("%Y-%m-%d %H:%M:%S")
        )
    )
    print(
        messages.CLI_VULNERABILITY_SHOW_JSON_PUBLISHED_AT.format(
            vulnerability_result.vulnerability_data_published_at.strftime(  # noqa
                "%Y-%m-%d %H:%M:%S"
            )
        )
    )
    print(
        messages.CLI_VULNERABILITY_SHOW_APT_UPDATED_AT.format(
            vulnerability_result.apt_updated_at.strftime("%Y-%m-%d %H:%M:%S")
        )
    )


def _show_description(vulnerability_issue):
    print(
        "\n"
        + messages.CLI_VULNERABILITY_SHOW_DESCRIPTION.format(
            vulnerability_issue.description
        )
        + "\n"
    )


def _show_cve_info(cfg: config.UAConfig, cve: str):
    cve_vulnerabilities_result = cve_vulnerabilities(
        options=CVEVulnerabilitiesOptions(), cfg=cfg
    )

    cve_data = None
    for cve_info in cve_vulnerabilities_result.cves:
        if cve_info.name == cve:
            cve_data = cve_info
            break

    if not cve_data:
        print(messages.CLI_VULNERABILITY_SHOW_NOT_AFFECTED)
        return

    _show_base_info(cve_vulnerabilities_result, cve_data)
    print(
        messages.CLI_VULNERABILITY_SHOW_UBUNTU_PRIORITY.format(
            cve_info.ubuntu_priority
        )
    )
    print(
        messages.CLI_VULNERABILITY_SHOW_CVSS_SCORE.format(cve_info.cvss_score)
    )
    print(
        messages.CLI_VULNERABILITY_SHOW_CVSS_SEVERITY.format(
            cve_info.cvss_severity
        )
    )
    _show_description(cve_data)

    if cve_data.notes:
        print(messages.CLI_VULNERABILITY_SHOW_NOTES)

        for note in cve_data.notes:
            print(note)


def _show_usn_info(usn: str):
    pass


@cli_util.assert_vulnerability_issue_valid
@assert_data_cache_updated(vulnerability_cmd="pro vulnerability show")
def action_show(args, *, cfg, **kwargs):
    if args.security_issue.startswith("CVE"):
        _show_cve_info(cfg=cfg, cve=args.security_issue)
    else:
        _show_usn_info(args.security_issue)

    return 0


def action_vulnerability(args, *, cfg, **kwargs):
    # Avoiding a circular import
    from uaclient.cli import get_parser

    get_parser().print_help_for_command("vulnerability")


show_subcommand = ProCommand(
    "show",
    help=messages.CLI_VULNERABILITY_SHOW,
    description=messages.CLI_VULNERABILITY_SHOW_DESC,
    action=action_show,
    preserve_description=True,
    argument_groups=[
        ProArgumentGroup(
            arguments=[
                ProArgument(
                    "security_issue",
                    help=messages.CLI_VULNERABILITY_SHOW_ISSUE,
                )
            ]
        )
    ],
)

vulnerability_command = ProCommand(
    "vulnerability",
    help=messages.CLI_ROOT_VULNERABILITY,
    description=messages.CLI_VULNERABILITY_DESC,
    action=action_vulnerability,
    subcommands=[show_subcommand],
)
